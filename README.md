# 송예진 202330117

## 6월 14일
<h3>자바 입출력 스트림</h3>

- 입출력 장치와 자바 응용 프로그램 연결
- 기본 단위 : 바이트 
- 단방향 스트림, 선입선출 구조

1. 문자 스트림
- 문자만 입출력
- 바이너리 데이터 처리 못함
- 데이터를 문자 출력하면 깨진 기호 출력
- 바이너리 파일 읽으면 읽을 수 없는 바이트가 생겨 오류

2. 바이트 스트림
  
<h3>스트림 연결</h3>

1. 여러개의 스트림을 연결하여 사용할 수 있음
<h4>문자스트림으로 텍스트 파일 읽기</h4>
<h4>텍스트 파일을 읽기 위해 문자 스트림 FileReader 클래스 이용</h4>
- 파일 입력 스트림 생성(파일 열기)
- 파일 읽기
- 스트림 닫기
  
<h3>파일 입출력과 예외 처리</h3>

1. 파일 입출력 동안 예외 발생 가능
- 스트림 생성 동안: FileNotFoundException 발생 가능
- 파일 읽기, 쓰기, 닫기를 하는 동안: IOException 발생 가능
2. try-catch 블록 반드시 필요
- 자바 컴파일러의 강제 사항
  
<h3>문자 스트림으로 텍스트 파일 쓰기</h3>

- 텍스트 파일에 쓰기 위해 문자 스트림 FileWriter 클래스 이용
1. 파일 출력 스트림 생성(파일 열기)
- 스트림 생성하고 파일을 열어 스트림과 연결
2. 파일 쓰기
- Write()로 문자 하나씩 파일에 기록
- 블록 단위로 쓰기 가능
3. 스트림 닫기
- close()로 스트림 닫기
  
<h3>문자 스트림으로 텍스트 파일 쓰기</h3>

- 텍스트 파일에 쓰기 위해 문자 스트림 FileWriter 클래스 이용
1. 파일 출력 스트림 생성(파일 열기)
- 스트림 생성하고 파일을 열어 스트림과 연결
2. 파일 쓰기
- Write()로 문자 하나씩 파일에 기록
- 블록 단위로 쓰기 가능
3. 스트림 닫기
- close()로 스트림 닫기
  
<h3>바이트 스트림으로 바이너리 파일 쓰기</h3>

- 바이너리 값을 파일에 저장하기  
1. 파일 출력 스트림 생성(파일 열기)
-스트림 생성하고 파일을 열어 스트림과 연결
2. 파일 쓰기
-Write()로 문자 하나씩 파일에 기록
3. 스트림 닫기
-close()로 스트림 닫기
  
<h3>File 클래스</h3>

- 파일의 경로명 및 속성을 다루는 클래스
- 파일 이름 변경,삭제, 디렉터리 생성, 크기 등 파일 관리
  
<h3>TCP/IP 소개</h3>

1. TCP/IP 프로토콜
- 두 시스템 간에 데이터가 손상없이 안전하게 전송되도록 하는 통신 프로토콜
- TCP에서 동작하는 응용프로그램 사례
2. TCP/TP 특징
- 연결형 통신
- 보낸 순서대로 받아 응용프로그램에게 전달


<h3>IP 주소</h3>

- 네트워크 상에서 유일하게 식별될 수 있는 컴퓨터 주소  
-숫자로 구성된 주소  
-4개의 숫자가 '.'으로 연결  
- 숫자로 된 주소는 기억하기 어려우므로 www.naver.com과 같은 문자열로 구성된 도메인 이름으로 바꿔 사용  
- 현재 32비트의 IP 버전 4(IPv4)가 사용되고 있음
-IP 주소 고갈로 인해 128비트 의 IP버전 6(IPv6)이 점점 사용되는 추세  
- 자신의 IP주소를 간단히 localhost라는 이름으로 사용 가능
  
<h3>포트</h3>

- 통신하는 프로그램 간에 가상의 연결단 포트 생성
-IP 주소는 네트워크 상의 컴퓨터 또는 시스템을 식별하는 주소
-포트 번호를 이용하여 통신할 응용프로그램 식별

- 모든 응용프로그램은 하나 이상의 포트 생성 가능
-포트를 이용하여 상대방 응용프로그램과 데이터 교환

- 잘 알려진 포트
-시스템이 사용하는 포트 번호
-잘 알려진 응용프로그램에서 사용하는 포트 번호
-잘 알려진 포트 번호는 개발자가 사용하지 않는 것이 좋음
  
<h3>소켓</h3>

- TCP/IP 네트워크를 이용하여 쉽게 통신 프로그램을 작성하도록 지원하는 기반 기술
- 소켓
-두 응용프로그램 간의 양방향 통신 링크의 한쪽 끝 단
-소켓끼리 데이터를 주고받음
-소켓은 특정 P 포트 번호와 결합
-자바로 소켓 통신할 수 있는 라이브러리 지원
-소켓 종류: 서버 소켓과 클라이언트 소켓

<h3>클라이언트에서 소켓으로 서버에 접속하는 코드</h3>
- 클라이언트 소켓 생성 및 서버에 접속
- 소켓으로부터 데이터를 전송할 입출력 스트림 생성
- 서버로 데이터 전송
- 서버로부터 데이터 수신
- 네트워크 접속 종료
  
<h3>서버에 클라이언트가 연결되는 과정</h3>

- 서버는 서버 소켓으로 들어오는 연결 요청으 기다림
- 클라이언트가 서버에게 연결 요청
- 서버가 연결 요청 수락
-새로운 클라이언트 소켓을 만들어 클라이언트와 통신하게 함
-그리고 다시 다른 클라이언트의 연결을 기다림
  
<h3>서버가 클라이언트와 통신하는 과정</h3>

- 서버 소켓 생성
- 클라이언트로부터 접속 기다림
- 네트워크 입출력 스트림 생성
  
<h3>서버-클라이언트 채팅 프로그램 만들기</h3>

1. 간단한 채팅 프로그램
- 서버와 클라이언트가 1:1로 채팅
- 클라이언트와 서버가 서로 한번씩 번갈아 가면서 문자열 전송
-

## 6월 7일
<h3>스윙 컴포넌트 그리기 paintComponent()</h3>

1. 스윙의 페인팅 기본
- 모든 컴포넌트는 자신의 모양을 스스로 그림
- 컨테이너는 자신을 그린 후 그 위에 자식 컴포넌트 그리기 지시
   
<h5>paintComponent와 오버라이딩</h5>

- 개발자가 jcomponent를 상속받아 새로은 컴포넌트 설계
  
<h5>그래픽 기반 GUI 프로그래밍</h5>

1. 그래픽 기반 GUI 프로그래밍
- 스윙 컴포넌트에 의존하지 않고 선, 원 이미지 등을 이용하여 직접 화면을 구성하는 방법
- 그래픽 기반 GUI 프로그래밍의 학습이 필요한 이유
  
2. 자바의 그래픽 좌표 시스템
  
<h5>Graphics와 문자열 출력</h5>

1. Graphics의 기능
- 색상 선택
- 문자열 그리기
- 도형 그리기
- 도형 칠하기
- 이미지 그리기
- 클리핑
  
<h5>도형그리기와 칠하기</h5>

1. Graphics의 기능
- 선, 타원, 사각형, 둥근 모서리 사각형, 원호, 폐 다각형 그리기
- 선의 굵기 조절할 수 없음
  
<h5>스윙에서 이미지를 그리는 2가지 방법</h5>

1. JLabel을 이용한 이미지 그리기
- 장점: 이미지 그리기 간편 용이
- 단점: 이미지의 원본 크기대로 그리므로 이미지 크기 조절 불가
  
2. Graphics의 drawImage()로 이미지 출력
- 장점: 이미지 일부분 등 이미지의 원본크기와 다르게 그리기 가능
- 단점: 컴포넌트로 관리할 수 없음, 이미지의 위치나 크기 드을 적절히 조절하는 코딩 필요

<h5>repaint</h5>

1. repaint()
- 모든 컴포넌트가 가지고 있는 메소드
- 자바 플랫폼에게 컴포넌ㄴ트 그리기를 강제 지시한느 메소드
- repaint()를 호출하면 자바 플랫폼이 컴포넌트의 paintComponent()호출

2. repaintm의 호출이 필요한 경우
- 개발자가 컴포넌트를 다시그리고자 하는 경우
  
<h5>repaint</h5>

1. repaint()
- 모든 컴포넌트가 가지고 있는 메소드
- 자바 플랫폼에게 컴포넌트 그리기를 강제 지시한느 메소드
- repaint()를 호출하면 자바 플랫폼이 컴포넌트의 paintComponent()호출

2. repaintm의 호출이 필요한 경우
- 개발자가 컴포넌트를 다시그리고자 하는 경우  

<h5>멀티태스킹 개념</h5>

1. 멀티태스킹
- 여러 개의 작업(태스크)이 동시에 처리되는 것
  
<h5>스레드와 운영체제</h5>

1. 스레드
- 운영체제에 의해 관리되는 하나의 작업 혹은 태스크
- 스레드와 태스크은 바꾸어 사용해도 무관

2. 멀티스레딩
- 여러 스레드르 동시에 실행시키는 응용프로그램을 작성하는 기법

3. 스레드 구성
- 스레드 코드
- 스레드 정보

<h5>멀티태스킹과 멀티스레딩</h5>

1. 멀티태스킹 구현 기술
- 멀티프로세싱
    - 하나의 응용프로그램이 여러 개의 프로세슬 생성하고 각 프로세스가 하나의 작업을 처리하는 기법
    - 각 프로세스 독립된 메모리 영역을 보유하고 실행
    - 프로스세 사이의 문맥 교환에 따른 과도한 오버헤드와 시간 소모의 문제점

- 멀티스레딩
    - 하나의 응용프로그램이 여러 개의 스레드를 생성하고, 각 스레드가 하나의 작업을 처리하는 기법
    - 하나의 응용프로그램에 속한 스레드는 변수 메모리, 파일 오픈 테이블 등 자원으로 공유하므로 문맥 교환에 따른 오버헤드가 매우 작음
    - 현재 대부분의 운영체제가 멀티스레딩을 기본으로 하고 있음
   
<h5>자바 스레드와 JVM</h5>

1. 자바 스레드
- 자바 가상 기계에 의해 스케쥴되는 실행 단위의 코드 블럭
- 스레드의 생명 주기는 JVM에 의해 관리됨

2. JVM과 자바의 멀티스레딩
- 하나의 JVM은 하나의 자바 응용프로그램만 실행
- 응용프로그램은 하나 이상의 스레드로 구성 가능
  
3. 스레드 만드는 2가지 방법
- Java.lang.Thread
- Java.lang.Runnable
  
<h5>Thread 클래스를 상속받아 스레드 만들기</h5>

1. Thread를 상속받아 run() 오버라이딩
- Thread 클래스 상속, 새 클래스 작성
- run() 메소드 작성

2. 스레드 객체 생성
- 생성된 객체는 필드와 메소드를 가진 객체일 뿐
    
<h5>Thread 클래스를 상속받아 스레드 만들기</h5>

1. Thread를 상속받아 run() 오버라이딩
- Thread 클래스 상속, 새 클래스 작성
- run() 메소드 작성
  
<h5>Runnable 인터페이스로 스레드 만들기</h5>

1. Runnable 인터페이스 구현하는 새 클래스 작성
- run() 메소드 구현
    - run() 메소드를 스레드 코드라고 부름
    - run() 메소드에서 스레드 실행 시작
2. 스레드 객체 생성
3. 스레드 시작
- start() 메소드 호출
    - 스레드로 작동 시작
    - 스레드 객체의 run()이 비로소 실행
    - JVM에 의해 스케쥴되기 시작함
  
<h5>main 스레드</h5>

1. main 스레드
- JVM이 응용프로그램을 실행할 때

<h5>스레드 종료와 스레드 강제 종료</h5>

1. 스스로 종료
- run() 메소드 리턴

2. 타 스레드에서 강제 종료
- interrupt() 메소드 사용

<h5>스레드 동기화</h5>

1. 멀티스레드 프로그램 작성시 주의점
- 다수의 스레드가 공유 데이터에 동시에 접근하는 경우

2. 스레드 동기화
- 동기화란: 스레드 사이의 실행순서 제어, 고유데이터에 대한 접근을 원활하게 하는 기법
- 멀티스레드의 공유 데이터의 동시 접근 문제 해결

3. 자바의 스레드 동기화 방법-2가지
- synchronized 키워드로 동기화 블록 지정
- wait()-notify() 메소드로 스레드의 실행 순서 제어

synchronized
  
<h5>synchronized 블록 지정</h5>

1. synchronized 키워드
- 스레드가 독점적으로 실행해야 하는 부분(동기화 코드)을 표시하는 키워드
- synchronized 블록 지정 방법: 메소드 전체 혹은 코드 블록

2. synchronized 블록이 실행될 때
- 먼저 실행한 스레드가 모니터 소유
- 모니터를 소유한 스레드가 모니터를 내놓을 때까지 다른 스레드 대기

<h5>wait()-notify()를 이용한 스레드 동기화</h5>

1. wait()-notify()가 필요한 경우
- 공유 데이터로 두 개 이상의 스레드가 데이터를 주고 받을 때
2. 동기화 메소드
- wait(): 다른 스레드가 notify()를 불러줄 때까지 기다림
- notify(): wait()를 호출하여 대기중인 스레드를 깨움


## 5월 31일
<h5>자바의 GUI 프로그래밍 방법 2 종류</h5>

- 컴포넌트 기반 GUI 프로그래밍
- 그래픽 기반 GUI 프로그래밍
  
<h5>스윙 컴포넌트의 공통 메소드. JComponent의 메소드</h5>

- 스윙 컴포넌트는 모두 상속받는 슈퍼 클래스. 추상 클래스
- 스윙 컴포넌트들이 상속받는 공통 메소드와 상수 구현
- JComponent의 주요 메소드 사례
  
<h5>JLabel로 문자열과 이미지 출력</h5>

- JLabel의 용도: 문자열이나 이미지를 화면에 출력하기 위한 목적

<h5>이미지 버튼 만들기</h5>

- 하나의 버튼에 3 개의 이미지 등록(마우스 조작에 따라 3개의 이미지 중 적절한 이미지 자동 출력)
- 3개의 버튼 이미지 normalIcon, rolloverIcon,
  
<h5>이미지 버튼</h5>

- 하나의 버튼에 3 개의 이미지 등록(마우스 조작에 따라 3개의 이미지 중 적절한 이미지 자동 출력)
- 3개의 버튼 이미지 normalIcon, rolloverIcon, pressedIcon
  
<h5>체크박스에 Item 이벤트 처리</h5>

1. item 이벤트s
- 체크 박스의 선택 상태에 변화가 생길 때 발생하는 이벤트
- 이벤트가 발생하면 itemEvent 객체 생성
- ItemListener 리스너를 이용하여 이벤트 처리  
  
<h5>JRadioButton으로 라디오 버튼 만들기</h5>

- JRadioButton의 용도: 버튼 그룹을 형성하고 그룹에 속한 버튼 중 하나만 선택되는 라디오버튼
- 그룹핑 필요

<h5>JTextField로 한 줄 입력 창 만들기</h5>

- 한 줄의 문자열을 입력 받는 창(텍스트 필드)
- 텍스트 입력 도중 엔터키가 입력되면 액션 이벤트 발생
  
<h5>JComboBox</h5>

<h5>메뉴 만들기 필요한 스윙 컴포턴트</h5>

- 메뉴아이템 JMenuItem
- 메뉴 JMenu
- 메뉴바 JMenuBar

1. item 이벤트
- 체크 박스의 선택 상태에 변화가 생길 때 발생하는 이벤트
- 이벤트가 발생하면 itemEvent 객체 생성
- ItemListener 리스너를 이용하여 이벤트 처리  
  
<h5>메뉴아이템에 Action 이벤트 달기</h5>

- 메뉴아이템을 클릭하면 Action 발생
- 메뉴아이템은 사용자로부터의 지시나 명령을 받는데 사용
- ActionLstener 인터페이스로 리스너 작성
- 각 메뉴아이템마다 이벤트 리스너 설정
  
<h5>다이얼로그</h5>

- 팝업 다이얼로그
- 입력 다이얼로그
- 확인 다이얼로그
- 메시지 다이얼로그


## 5월 24일 리스너 인터페이스
<h5>이벤트 기반 프로그래밍</h5>

- 이벤트의 발생에 의해 프로그램 흐름이 결정되는 방식
- 반대되는 개념: 배치 실행
- 이벤트 종류(사용자의 입력, 센서로부터의 입력, 네트워크로부터 데이터 송수신, 다른 응용프로그램이나 다른 스레드로부터의 메시지)
  
<h5>이벤트 기반 응용 프로그램의 구조</h5>

- 각 이벤트마다 처리하는 리스너 코드 보유
  
<h5>GUI 응용프로그램은 이벤트 기반 프로그래밍으로 작성됨</h5>

- GUI 라이브러리 종류(C++의 MFC, C# GUI, Visual Basic, C Window, Android 등)
- 자바의 AWT와 Swing
  
<h5>이벤트가 처리되는 과정</h5>

- 이벤트 발생
- 이벤트 객체 생성
- 응용프로그램에 작성된 이벤트 리스너 찾기
- 이벤트 리스너 실행(리스너에 이벤트 객체 전달, 리스너 코드 실행)

<h5>이벤트 객체</h5>

- 발생한 이벤트에 관한 정보를 가진 객체
- 이벤트 리스너에 전달됨

<h5>이벤트 객체가 포함하는 정보</h5>

- 이벤트 종류와 이벤트 소스
- 이벤트가 발상한 화면 좌표 및 컴포넌트 내 좌표
- 이벤트가 발생한 버튼이나 메뉴 아이템의 문자열
- 클릭된 마우스 버튼 번호 및 마우스의 클릭 횟수
- 키의 코드 값과 문자 값
- 체크박스, 라디오버튼 등과 같은 컴포넌트에 이벤트가 발생하였다면 체크 상태
  
<h5>이벤트 소스를 알아 내는 메소드</h5>
<h4>Object getSource()</h4>

- 발생한 이벤트의 소스 컴포넌트 리턴
- Object 타입으로 리턴하므로 캐스팅하여 사용
- 모든 이벤트 객체에 대해 적용
  
<h5>이벤트 리스너</h5>

- 이벤트를 처리하는 자바 프로그램 코드, 클래스로 작성
<h5>자바는 다양한리스너 인터페이스 제공</h5>
<h5>사용자의 이벤트 리스너 작성</h5>

- 자바의 리스너 인터페이스를 상속받아 구현
- 리스너 인터페이스의 모든 추상 메소드 구현
  
<h5>이벤트 리스너 작성 과정 사례</h5>

1. 이벤트와 이벤트 리스너 선택
 - 버튼 클릭을 처리하고자 하는 경우(이벤트: Action, 이벤트 리스너: ActionListener)

2. 이벤트 리스너 클래스 작성: ActionListener 인터페이스 구현  

<h3>이벤트 리스너 작성 방법</h3>
<h5>독립 클래스로 작성</h5>

- 이번트 리스너를 완전한 클래스로 작성
- 이번트 리스너를 여러 곳에서 사용할 때 적합
  
<h5>내부 클래스로 작성</h5>

- 클래스 안에 멤버처럼 클래스 작성
- 이벤트 리스너를 특정한 클래스에서만 사용할 때 적합
  
<h5>익명 클래스로 작성</h5>

- 클래스 이름 없이 간단히 리스너 작성
- 클래스 조차 만들 필요없이 리스너코드가 간단한 경우에 적합
  
<h5>익명 클래스로 이벤트 리스너 작성</h5>

- 익명 클래스: 이름 없는 클래스(클래스 선어+인스턴스 생성)을 한 번에 달성
- 간단한 리스너의 경우 익명 클래스 사용 추천(메소드의 개수가 1, 2개인 리스너에 대해 주로 사용)
  
<h4>어댑터 클래스</h4>
<h5>이벤트 리스너 구현에 따른 부담</h5>

- 리스너 추상 메소드를 모두 구현해야 하는 부담
  
<h4>Key 이벤트와 포커스</h4>
<h5>키 입력시, 다음 세 경우 각각 Key 이벤트 발생</h5>

- 키를 누르는 순간
- 누른 키를 떼는 순간
- 누른 키를 떼는 순간(Unicode 키의 경우에만)

<h5>키 이벤트를 받을 수 있는 조건</h5>

- 모든 컴포넌트
- 현재 포커스를 가진 컴포넌트가 키 이벤트 독점
  
<h5>KeyListener</h5>

- 응용프로그램에서 KeyListener를 상속받아 키 리스너 구현
- KeyListener의 3 개 메소드
- 컴포넌트에 키 이벤트 리스너 달기
  
<h4>유니코드 키</h4>
<h5>유니코드 키의 특징</h5>

- 국제 산업 표준
- 전 세계의 문자를 컴퓨터에서 일관되게 표현하기 위한 코드 체계
- 문자들에 대해서만 키 코드 값 정의
- 문자가 아닌 키 경우에는 표준화된 키 코드 값 없음
  
<h5>유니코드가 키가 입력되는 경우</h5>

- keyPressed(), keyTyped(), keyReleased()가 순서대로 호출
  
<h4>가상 키와 입력된 키 판별</h4>
<h5>KeyEvent 객체</h5>

- 입력된 키 정보를 가진 이벤트 객체
- KeyEvent 객체의 메소드로 입력된 키 판별

<h5>KeyEvent 객체의 메소드로 입력된 키 판별</h5>

- char KeyEventgetKeyChar()
- int KeyEventgetKeyCode()
  
<h5>가상 키(Virtual Key)</h5>

- 가상 키는 KeyEvent 클래스에 상수로 선언
 


  

## 5월 17일
컨테이너와 배치, 배치관리자 개념

배치 관리자 대표 유형 4가지
<h5>FlowLayout</h5>

- 컴포턴트과 삽입되는 순서대로 왼쪽으서 오른쪽으로 배치
- 배치할 공간이 없으면 아래로 내려와서 반복  
<h5>BorderLayout</h5>

- 컴테이너의 공간을 동, 서, 남, 북, 중앙의 5개 영역으로 나눔
- 5개 영역 중 응용프로그램에서 지정한 영역에 컴포넌트 배치
- add() 메소드: comp 컴포턴트를 index 위치에 삽입/ index: 컴포넌트의 위치  
<h5>GridLayout</h5>

- 컨테이너를 프로그램에서 설정한 동일한 크기의 2차원 격자로 나눔
- 컴포넌트는 삽입 순서대로 좌에서 우로, 다시 위에서 아래로 배치  
- 생성자: GridLayout(),GridLayout(int rows, int cols),GridLayout(int rows, int cols, int hGap, int vGap)  
<h5>CardLayout</h5>

- 컨테이너의 공간에 카드를 쌓아 놓은 듯이 컴포넌트를 포개어 배치  

<h5>컨테이너의 디폴트 배치관리자</h5>

- 컨테이너 생성시 자동으로 생성되는 배치관리자   

<h5>배치관리자가 없는 컨테이너</h5>

- 응용프로그램에서 직접 컴포넌트의 크기와 위치를 결정하고자 하는 경우
 1. 컴포넌트의 크기나 위치를 개발자 임으로 결정하고자 하는 경우
 2. 게임 프로그램과 같이 시간이나 마우스/키보드의 입력에 따라 컴포넌트들의 위치와 크기가 수시로 변하는 경우
 3. 여러 컴포넌트들이 서로 겹쳐 출력하고자 하는 경우
 - containersetLayout(null);  

<h5>배치관리자가 없는 컨테이너</h5>

- 배치관리자가 없는 컨테이너에 컴포넌트를 삽입할 때
1. 프로그램에서 컴포넌트의 절대 크기와 위치 설정
2. 컴포넌트들이 서로 겹치게 할 수 있음

## 5월 3일
컬렉션 자바 인터페이스와 클래스
벡터의 특성
- &lt E &gt 에 사용할 요소의 특정 타입으로 구체화
- 배열을 가진 크기로 다룰 수 있게 하는 컨테이너
- 요소 객체들을 삽입, 삭제, 검색하는 컨테이너
  
ArrayList &lt E &gt
- 가변 크기 배열을 구현한 클래스
- 벡터와 거의 동일
  
HasgMap &lt K, v &gt
- 키와 값의 쌍으로 구성되는 요소를 다루는 컬렉션
- 삽입 및 검색이 빠른 특징
  
GUI 응용프로그램  
AWT와 SWING 패키지
  
컨테이너
- 다른 컴포넌트를 포함할 수 있는 GUI 컴포넌트
- 다른 컨테이너에 포함될 수 있음
  
컴포넌트
- 컨테이너에 포함되어야 화면에 출력될 수 있는 GUI 객체
- 다른 컴포넌트를 포함할 수 없는 순수 컨테이너

## 4월 19일
추상 클래스(abstract) 상속  
- 추상 클래스를 상속받으면 추상 클래스가 됨
  
추상 클래스 구현
  
추상 클래스의 목적
- 상속을 위한 슈퍼 클래스로 활용하는 것
- 서브 클래스에서 추상 메소드 구현
- 다형성 실현
  
자바의 인터페이스
- 클래스가 구현해야 할 메소드들이 선언되는 추상형
- 인터페이스선언 키워드로 선언 

자바 인터페이스에 대한 변화  
자바7까지  
- 인터페이스는 상수와 추상 메소드로만 구성
  
- 여전히 인터페이스에는 필드(멤버변수) 선언 불가
  
인터페이스의 구성요소들
- 상수, 추상 메소드, default 메소드, private 메소드, static
  
인터페이스 상속
- 인터페이스 간에 상속 가능
- 인터페이스 다중 상속 허용

- *오버라이딩*, *오버로딩*

<h3> 6장 </h3>
6장 1,2,3은 많이 사용 중  
패키지 개념과 필요성
-  합칠 때 오류 발생 감소
  
패키지
- 서로 관련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묵어 놓은 디렉터리
- 하나의 응용프로그램은 한 개 이상의 패키지로 작성
- 패키지는 jar 파일로 압축할 수 있음
  
모듈
- 여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너
- 하나의 모듈을 하나의 .jmod 파일에 저장  
자바9부터 모듈화 도입
- 플랫폼의 모듈화
- 응용프로그램의 모듈화
  
모듈화의 목적
- 자바9부터 자바api를 여러 모듈(99개)로 분할
- 응용프로그램이 실행할 때 꼭 필요한 모듈들로만 실행환경 구축
  
모듈의 현실
- 자바9부터 전면적으로 도입
- 복잡한 개념
- 큰 자바 응용프로그램에는 개발, 유지보수 등에 적합
- 현실적으로 모듈로 나누어 자바 프로그램을 작성할 필요 없음
  
자바JDK에 제공되는 모듈 파일들
- 자바가 설치된 jmods 디렉터리에 모듈 파일 존재
- 모듈 파일에는 자바API의 패키지와 클래스들이 들어 있음
  
패키지 사용하기, import문
- 다른 패키지에 작성된 클래스 사용(import 사용x)<-이렇게 사용안함
- 필요한 클래스만 iport(import java.util.Scanner;)
- 패키지 전체를 import(import java.util.*;)
  
클래스 파일이 저장되는 위치
- 패키지로 선언된 디렉터리에 저장
  
패키지 선언
- 소스 파일의 맨 앞에 컴파일 후 저장될 패키지 지정
  
java projects > java2-1-1 > src + > package > package 이름(java2.add)
java2.add + > class > class 이름(Add.java)
  
자바 모듈화이 목적
- 자바 컴포넌트들을 필요에 따라 조립하여 사용하기 위함
- 컴퓨터 시스템의 불필요한 부담 감소
  
모든 자바 클래스는 반드시 object를 상속받도록 자동 컴파일

객체 비교(==)와 equals() 메소드
  
박싱, 언박싱  
박싱: 기본 타입이 값을wrapper 객체로 변환
언박싱: 박싱의 반대 wrapper 객체에 들어 있는 기본 타입의 값을 빼내는 것
  
스트링 리터럴과 new String()
스트링 리터럴
- 자바 가상 기계 내부에서 리터럴 테이블에 저장되고 관리됨
- 응용프로그램에서 공유됨

new String()으로 생성된 스트링
- 스트링 객체는 힙에 생성
- 스트링은 공유되지 않음
  
Math클래스
- 기본 산술 연산 메소드를 제공하는 클래스
- 모든 메소드는 static으로 선언

<h3> 시험 범위 6장까지
패키지와 모듈 개념 이해, 사용자 패키지 만들기, 자바에서 제공하는 표준 패키지

- 수요일 시험 시간 50분, 코드완성 or 채워넣기, 오류 수정
- 오픈북, 인터넷 사용 가능!
  

## 4월 12일
static 멤버 사용
- 클래스 이름으로 접근 가능
- 객체의 멤버로 접근 가능
- non-static 멤버는 클래스 이름으로 접근 안 됨  
전역 변수와 전역 함수를 만들 때 사용  
공유 멤버를 만들 때 사용  
static 메소드의 제약 조건
- static 메소드는 오직 static 멤버만 접근 가능
- static 메소드는 this 사용불가<h6>(static메소드는 객체상관없이 사용가능) 
  
final 클래스와 메소드
- final 클래스 더이상 클래스 상속(오버라이딩) 불가능
  
final 필드, 상수선언
- 상수를 선언할 때 사용
- 상수 필드는 선언 시 에 초기값 지정
- 실행 줄 값 변경할 수 없다.
  
클래스 상속과 객체
1. 상속 선언
- extends 키워드로 선언(부모 클래스를 물려받아 확장한다는 의미)
- 부모 클래스 -> 슈퍼클래스(super class)
- 자식 클래스 -> 서브 클래스(sub class)
  
슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
- 슈퍼 클래스의 private 멤버(서브 클래스에서 접근 불가)
- 슈퍼 클래스의 default 멤버(서브 클래스가 동일한 페키지 있을 때 접근가능)
- 슈퍼 클래스의 public 멤버
- 슈퍼 클래스의 protected 멤버
  
protected 멤버에 대한 접근
- 같은 패키지의 모든 클래스 허용
- 상속되는 서브 클래스에게 허용(같은 패키지든 다른 패키지든 상관없이)
  
생성자: 객체 초기화시켜줌  
초기화 시킬 것이 없으면 생성자 없어도 됨  
하지만 내부적으로 오류있음  
기본 생성자: 매개변수 없음  

- 슈퍼 클래스와 서브 클래스 각각 여러 개의 생성자 작성 가능
- 서브 클래스의 객체가 생성될 때 슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개 실행
- 서브 클래스의 생성자아 슈퍼클래스의 생성자가 결정되는 방식
 - 1. 개발자의 명시적 선택
 - 2. 컴파일러가 기본생성자 선택
  
업캐스팅 개념
- 서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
- 슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가르키게 되는 현상
- 슈퍼 클래스 레퍼런스로 객체 내의 슈퍼 클래스의 멤버만 접근 가능
  
다운캐스팅
- 슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입
- 업캐스팅된 것을 다시 원래대로 되돌리는 것
- 반드시 명시적 타입 변환 지정
  
업캐스팅된 레퍼런스로는 객체이 실제 타입을 구분하기 어려움  
-슈퍼클래스는 여러 서브 클래스에 상속되기 때문
  
instanceof 연산자
- 레퍼런스가 가리키는 객체의 타입 식별

메소드 오버라이딩
- 서브 클래스에서 슈퍼 클래스의 메소드 중
  
정적 바인딩 동적 바인딩

추상 메소드
추상 클래스

  
## 4월 5일
2차원 배열  
자바 상속
- 상위 클래스의 멤버를 하위 클래스가 물려받음
- 상위 클래스: 수퍼 클래스  

소프트웨어의 생산성 향상
- 컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기 단축
- 객체 지향 언어 

실세계에 대한 쉬운 모델링
- 초기 프로그래밍
- 현대 프로그래밍
- 객체 지향 언어

절차 지향 프로그래밍
- 작업 순서를 표현하는 컴퓨터 명령 집합
- 함수들의 집합으로 프로그램 작성

객체 지향 프로그래밍
- 컴퓨터가 수행하는 작업을 객체들간의 상호작용으로 표현
- 클래스 혹은 객체들의 집합으로 프로그램 작성

생성자의 특징
- 생성자 이름은 클래스 이름과 동일
- 생성자는 여러 개 작성 가능(생성자 중복)
- 생성자는 객체 생성시 한 번만 호출

객체 소멸
- new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위
- 소멸된 객체 공간은 가용 메모리에 포함

자바에서 사용자 임의로 객체 소멸안됨
- 자바는 객체 소멸 연산자 없음
- 객체 소멸은 자바 가상 기계의 고유한 역할
- 자바 개발자에게는 매우 다행스러운 기능

가비지
- 가리키는 레퍼런스가 하나도 없는 객체
가비지 컬렉션
- 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 반환

클래스 접근지정



## 3월 29일 강의
- Scanner를 이용한 키 입력  
- 개발자가 원하는 타입 값으로 쉽게 읽을 수 있음  
- 산술연산자(+, -, *, /, %)  
- 조건 연산(3 개의 피연산자로 구성된 삼항(ternary)연산자)  

- 학습목표
1. 반복문
2. continue문과 break문 활용
3. 자바의 배열 선언 및 활용
4. 배열을 리턴하는 메소드 작성
5. 예외 개념과 자바에서의 예외 처리

## 3월 22일 강의 자바의 플랫폼 독립성
WORA(Write Once Run AnuWhere)  
-한번 작성된 코드는 모든 플랫폼에서 바로 실행  
-c/c++ 등 기존 언어가 가진 플랫폼 종속성 극복  
-네트워크에 연결된 어느 클라이언트에서나 실행  
  
WORA를 가능하게 하는 자바의 특징  
-바이트코드(바이너리 코드)  
-JVM(자바 가상 기계)  

JDK와 JRE  
-JDK 자바 응용 개발 환경, 개발에 필요한 도구 포함  
-JRE 자바 실행 환경, 개발자가 아닌 경우 JRE만 따로 다운 가능  
-JDk의 bin 디렉터리에 포함된 주요 개발 도구 javac java jmod jdb javap jlink javadoc jar  

자바 응용의 종류: 서블릿 응용프로그램  
서블릿(servlet)  
-웹 서버에서 실행되는 자바 프로그램  
-데이터베이스 서버 및 기타 서버와 연동하는 복잡한 기능 구현 시 사용  
-사용자 인터페이스가 필요 없는 응용  
-웹 서버에 의해 실행 통제 받음  
안드로이드  
-구글의주도로 여러 모바일 회사가 모여 구성한 OHA에서 만든 무료 모바일 플랫폼  
-개발언어는 자바를 사용하나 jvm에 해당하는 Dalvik은 기존 바이트 코드와 호환성이 없어 변환 필요  

자바의 특성
1. 플랫폼 독립성  
-하드웨어, 운영체제에 종속되지 않는 바이트 코드로 플랫폼 독립성  
2. 객체지향  
-캡슐화, 상송, 다형성 지원
3. 클래스로 캡슐화  
-자바의 모든 변수나 함수는 클래스 내에 선언  
-클래스 안에서 클래스(내부 클래스) 작성 가능  
4. 소스(.java)와 클래스(.class) 파일  
-클래스 파일에는 하나의 클래스만 존재  
-하나의 소스 파일에 여러 클래스를 작성 가능  
-소스 파일의 이름과 public으로 선언된 클래스 이름은 같아야 함  

자바의 특징(2)
1. 실행 코드 배포
2. 패키지
3. 멀티스레드
4. 가비지 컬렉션

자바의 특징(3)
1. 실시간 응용프로그램에 부적합
2. 자바 프로그램은 안전
3. 프로그램 작성 쉬움
4. 실행 속도 개선을 위한 JIT 컴파일러 사용

문자열은 기본 타입이 아님(String 클래스로 문자열 표현)  
상수는 전부 대문자로  
var 키워드  
-java10부터 도입  
-기존의 변수 선언 방식: 변수의 타입 반드시 지정  
-타입을 생략하고 변수 선언 가능  
-컴파일러가 추론하여 변수 타입 결정  

## 3월 15일 강의
내용정리

# java2-1
개요는 리드미에 나온다